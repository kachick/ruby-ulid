# Classes
class ULID
  VERSION: String
  TIMESTAMP_ENCODED_LENGTH: 10
  RANDOMNESS_ENCODED_LENGTH: 16
  ENCODED_LENGTH: 26
  TIMESTAMP_OCTETS_LENGTH: 6
  RANDOMNESS_OCTETS_LENGTH: 10
  OCTETS_LENGTH: 16
  MAX_MILLISECONDS: 281474976710655
  MAX_ENTROPY: 1208925819614629174706175
  MAX_INTEGER: 340282366920938463463374607431768211455
  TIME_FORMAT_IN_INSPECT: '%Y-%m-%d %H:%M:%S.%3N %Z'
  PATTERN: Regexp
  STRICT_PATTERN: Regexp
  UUIDV4_PATTERN: Regexp
  N32_CHAR_BY_CROCKFORD_BASE32_CHAR: Hash[String, String]
  CROCKFORD_BASE32_CHAR_PATTERN: Regexp
  CROCKFORD_BASE32_CHAR_BY_N32_CHAR: Hash[String, String]
  N32_CHAR_PATTERN: Regexp
  MIN: ULID
  MAX: ULID
  UNDEFINED: BasicObject
  include Comparable

  # The `moment` is a `Time` or `Intger of the milliseconds`
  type moment = Time | Integer

  class Error < StandardError
  end

  class OverflowError < Error
  end

  class ParserError < Error
  end

  class SetupError < ScriptError
  end

  class MonotonicGenerator
    attr_accessor latest_milliseconds: Integer
    attr_accessor latest_entropy: Integer
    def initialize: -> void
    def generate: (?moment: moment) -> ULID
    def reset: -> void
    def freeze: -> void
  end

  type octets = [Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer]
  type timestamp_octets = [Integer, Integer, Integer, Integer, Integer, Integer]
  type randomness_octets = [Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer]

  @milliseconds: Integer
  @entropy: Integer
  @string: String?
  @integer: Integer?
  @octets: octets?
  @timestamp_octets: timestamp_octets?
  @randomness_octets: randomness_octets?
  @timestamp: String?
  @randomness: String?
  @inspect: String?
  @time: Time?
  @next: ULID?

  def self.generate: (?moment: moment, ?entropy: Integer) -> ULID
  def self.at: (Time time) -> ULID
  def self.current_milliseconds: -> Integer
  def self.milliseconds_from_time: (Time time) -> Integer
  def self.milliseconds_from_moment: (moment moment) -> Integer
  def self.range: (Range[Time] | Range[nil] time_range) -> Range[ULID]
  def self.floor: (Time time) -> Time
  def self.reasonable_entropy: -> Integer
  def self.parse: (String string) -> ULID
  def self.from_uuidv4: (String uuid) -> ULID
  def self.from_integer: (Integer integer) -> ULID
  def self.min: (?moment: moment) -> ULID
  def self.max: (?moment: moment) -> ULID
  def self.sample: -> ULID
                 | (Integer number) -> Array[ULID]
  def self.valid?: (untyped string) -> bool
  def self.scan:  (String string) -> Enumerator[ULID, singleton(ULID)]
                | (String string) { (ULID ulid) -> void } -> singleton(ULID)
  def self.octets_from_integer: (Integer integer) -> octets
  def self.from_monotonic_generator: (MonotonicGenerator generator) -> ULID
  attr_reader milliseconds: Integer
  attr_reader entropy: Integer
  def initialize: (milliseconds: Integer, entropy: Integer, ?integer: Integer) -> void
  def to_s: -> String
  def to_i: -> Integer
  alias hash to_i
  def <=>: (ULID other) -> Integer
         | (untyped other) -> nil
  def inspect: -> String
  def eql?: (untyped other) -> bool
  alias == eql?
  def ===: (untyped other) -> bool
  def to_time: -> Time
  def timestamp: -> String
  def randomness: -> String
  def patterns: -> Hash[Symbol, Regexp | String]
  def pattern: -> Regexp
  def strict_pattern: -> Regexp
  def octets: -> octets
  def timestamp_octets: -> timestamp_octets
  def randomness_octets: -> randomness_octets
  def to_uuidv4: -> String
  def next: -> ULID?
  alias succ next
  def pred: -> ULID?
  def freeze: -> self

  private
  def self.argument_error_for_range_building: (untyped argument) -> ArgumentError
  def cache_all_instance_variables: -> void
end
