# Classes
class ULID
  VERSION: String
  ENCODING_CHARS: Array[String]
  TIMESTAMP_PART_LENGTH: 10
  RANDOMNESS_PART_LENGTH: 16
  ENCODED_ID_LENGTH: 26
  TIMESTAMP_OCTETS_LENGTH: 6
  RANDOMNESS_OCTETS_LENGTH: 10
  OCTETS_LENGTH: 16
  MAX_MILLISECONDS: 281474976710655
  MAX_ENTROPY: 1208925819614629174706175
  MAX_INTEGER: 340282366920938463463374607431768211455
  TIME_FORMAT_IN_INSPECT: '%Y-%m-%d %H:%M:%S.%3N %Z'
  PATTERN: Regexp
  STRICT_PATTERN: Regexp
  UUIDV4_PATTERN: Regexp
  MONOTONIC_GENERATOR: MonotonicGenerator
  include Comparable

  type moment = Time | Integer

  class Error < StandardError
  end

  class OverflowError < Error
  end

  class ParserError < Error
  end

  class MonotonicGenerator
    attr_accessor latest_milliseconds: Integer
    attr_accessor latest_entropy: Integer
    def initialize: -> void
    def generate: (?moment: moment) -> ULID
    def reset: -> void
    def freeze: -> void
  end

  type octets = [Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer]
  type timestamp_octets = [Integer, Integer, Integer, Integer, Integer, Integer]
  type randomness_octets = [Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer]

  @milliseconds: Integer
  @entropy: Integer
  @string: String?
  @integer: Integer?
  @octets: octets?
  @timestamp_octets: timestamp_octets?
  @randomness_octets: randomness_octets?
  @timestamp: String?
  @randomness: String?
  @inspect: String?
  @time: Time?
  @next: ULID?
  @pattern: Regexp?
  @strict_pattern: Regexp?
  @matchdata: MatchData?

  def self.generate: (?moment: moment, ?entropy: Integer) -> ULID
  def self.monotonic_generate: -> ULID
  def self.current_milliseconds: -> Integer
  def self.milliseconds_from_time: (Time time) -> Integer
  def self.milliseconds_from_moment: (moment moment) -> Integer
  def self.range: (Range[Time] time_range) -> Range[ULID]
  def self.floor: (Time time) -> Time
  def self.reasonable_entropy: -> Integer
  def self.parse: (String string) -> ULID
  def self.from_uuidv4: (String uuid) -> ULID
  def self.from_integer: (Integer integer) -> ULID
  def self.min: (?moment: moment) -> ULID
  def self.max: (?moment: moment) -> ULID
  def self.valid?: (untyped string) -> bool
  def self.scan:  (String string) -> Enumerator[ULID, singleton(ULID)]
                | (String string) { (ULID ulid) -> void } -> singleton(ULID)
  def self.octets_from_integer: (Integer integer, length: Integer) -> Array[Integer]
  def self.inverse_of_digits: (Array[Integer] reversed_digits) -> Integer
  attr_reader milliseconds: Integer
  attr_reader entropy: Integer
  def initialize: (milliseconds: Integer, entropy: Integer) -> void
  def to_str: -> String
  alias to_s to_str
  def to_i: -> Integer
  alias hash to_i
  def <=>: (ULID other) -> Integer
         | (untyped other) -> Integer?
  def inspect: -> String
  def eql?: (untyped other) -> bool
  alias == eql?
  def ===: (untyped other) -> bool
  def to_time: -> Time
  def timestamp: -> String
  def randomness: -> String
  def pattern: -> Regexp
  def strict_pattern: -> Regexp
  def octets: -> octets
  def timestamp_octets: -> timestamp_octets
  def randomness_octets: -> randomness_octets
  def next: -> ULID?
  alias succ next
  def pred: -> ULID?
  def freeze: -> self

  private
  def matchdata: -> MatchData
end
